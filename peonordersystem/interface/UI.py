"""UI module stores the UI object which instantiates
and controls the main underlying GUI with user
interactions being compatible. All functionality of
the main GUI is utilized as components in UI object.

@author: Carl McGraw
@contact: cjmcgraw.u.washington.edu
@version: 1.0
"""
from peonordersystem.path import MAIN_UI_PATH

import copy

from peonordersystem.interface import Builder
from peonordersystem.interface.Orders import Orders
from peonordersystem.interface.Reservations import Reservations
from peonordersystem.interface import Editor
from peonordersystem.interface.UpcomingOrders import UpcomingOrders
from peonordersystem import ErrorLogger
from peonordersystem import CustomExceptions


def non_fatal_error_notification(func):
    """Decorator Function.

    This function acts as the exterior
    wrapper that is wrapped around the
    decorated method.

    @param func: function pointer of the
    function/method that was called.

    @return: function pointer to the modified
    function/method
    """
    def error_checker(self, *args, **kwargs):
        """Function Wrapper.

        This function acts as the interior wrapper
        that is called when the Decorator Function
        is called. This methods parameters match
        exactly the parameters passed to the
        method/function being called.

        @param args: wildcard catchall for all
        arguments passed into the function/method.

        @param self: reference to the object that
        has had its method called.

        @param kwargs: wildcard catchall for all
        keyword arguments passed into the
        function/method.

        @return: result of the return value
        generated by the
        """
        try:
            result = func(self, *args, **kwargs)
            return result

        except CustomExceptions.InvalidItemError:
            self.update_status(CustomExceptions.INVALID_ITEM_MESSAGE,
                               ['error'])

        except CustomExceptions.InvalidOrderError:
            self.update_status(CustomExceptions.INVALID_ORDER_MESSAGE,
                               ['error'])

        except CustomExceptions.InvalidReservationError:
            self.update_status(CustomExceptions.INVALID_RESERVATION_MESSAGE,
                               ['error'])

        except CustomExceptions.NoSuchSelectionError:
            self.update_status(CustomExceptions.NO_SELECTION_MESSAGE,
                               ['error'])

    return error_checker


class UI(object):
    """UI Object operates on higher level functions of the
    PeonOrderSystem GUI. Functionally it instantiates all
    user side interactions of the GUI and ties them together.
    
    @var builder: Builder object that holds all information
    about generated base GUI from xml file
    
    @var orders: Orders object that stores and operates the
    table orders, also displays them.
    
    @var reservations: Reservations object that stores and
    operates the current reservations. 
    
    @var upcoming_orders: UpcomingOrders object that stores
    and operates the current upcoming orders display.
    
    @var editor: Editor object that operates and displays
    dialog windows.
    """
    @non_fatal_error_notification
    @ErrorLogger.log_func_data
    def __init__(self, title, load_data=None):
        """Initializes a new object. Generates the base GUI
        from XML file obtained from Path. Instantiates the
        component objects.
        
        @param title: str representing the current title to
        be displayed on the GUI
        """
        self.builder = Builder.Builder()
        
        self.builder.add_from_file(MAIN_UI_PATH, title)
        self.builder.connect_signals(self)
        
        # These objects control the main orders and their displays
        self.orders = Orders(load_data=load_data)
        self.builder.set_menu_item_view(self.orders.get_display_view())
        
        # These objects control secondary displays
        self.reservations = Reservations(self.builder.reservation_window)
        self.upcoming_orders = UpcomingOrders(self.builder.upcoming_orders_window,
                                              load_data=load_data)
        
        # These objects control dialog windows.
        self.editor = Editor.Editor(self.builder.window)
        self.update_status('Awaiting input...')
    
    #===========================================================================
    # This block contains methods that add, remove, or otherwise alter
    # an entire order. Such as adding, removing menu items or selecting
    # an order
    #===========================================================================

    @non_fatal_error_notification
    @ErrorLogger.log_func_data
    def table_button_clicked(self, table_button, table):
        """Callback method called when a table button is clicked.
        This method sets the current order to be displayed as
        the same as the table button clicked.
        
        @param table_button: Gtk.Button widget representing
        the current table button clicked.
        
        @param table: str representing the stored text on the
        table button.
        """
        self.builder.set_table(table)
        self.orders.set_current_table(table)
        self.update_status('Order set to {}'.format(table))

    @non_fatal_error_notification
    @ErrorLogger.log_func_data
    def menu_button_clicked(self, menu_button, menu_item):
        """Callback method called when a menu button has been
        clicked. 
        
        @param menu_button: Gtk.Button object.
        
        @param menu_item: MenuItem object that represents
        the MenuItem associated with the clicked button.
        """
        item_name = menu_item.get_name()
        self.orders.add(copy.copy(menu_item))
        self.update_status('{} added to current order'.format(item_name))

    @non_fatal_error_notification
    @ErrorLogger.log_func_data
    def remove_menu_item(self, *args):  # @IGNORE:W0613
        """Removes currently selected MenuItem
        from the order.
        
        @param *args: wildcard representing the 
        selected menu button "remove". This parameter
        is added as a catch all.
        """
        menu_item = self.orders.remove()
        name = menu_item.get_name()
        self.update_status('{} removed from current order'.format(name))

    #===========================================================================
    # This block contains methods that pertain directly to the reservations
    # and upcoming orders tabbed pane of the XML generated by self.builder
    #===========================================================================

    @non_fatal_error_notification
    @ErrorLogger.log_func_data
    def add_new_reservation(self, *args):  # @IGNORE:W0613
        """Callback method when reservation has been added.
        Calls dialog window to get new reservation information
        and adds it to the reservations displayed.
        
        @param *args: wildcard representing the widget of
        the selected item 
        """
        self.update_status('Waiting for new reservation...')
        confirmed_function = self.add_reservation_confirmed
        confirmed = self.editor.add_new_reservation(confirmed_function)
        if confirmed:
            message = 'Adding New Reservation...'
        else:
            message = 'Cancelled reservation dialog'
        self.update_status(message)

    @non_fatal_error_notification
    @ErrorLogger.log_func_data
    def remove_selected_reservation(self, *args):  # @IGNORE:W0613
        """Callback method called when remove reservation
        has been clicked. Removes the selected reservation
        from the reservations list.
        
        @param *args: wildcard that represents a catch
        for selected widget 
        """
        self.update_status('Removing selected reservation...')
        name, number, arrival_time = self.reservations.remove_selected_reservation()
        self.update_status('Removed reservation for {} at {}'.format(name,
                                                                     arrival_time))

    @non_fatal_error_notification
    @ErrorLogger.log_func_data
    def confirm_selected_upcoming_order(self, *args):
        """Callback method called when the confirm priority
        button for the upcoming orders tab is pressed.
        
        @param *args: wildcard that represents a catch
        for the selected widget
        """
        name = self.upcoming_orders.confirm_priority()
        self.update_status('Confirmed priority on {}'.format(name))

    @non_fatal_error_notification
    @ErrorLogger.log_func_data
    def remove_selected_upcoming_order(self, *args):
        """Callback Method. Called when the remove
        order button for the upcoming orders tab is
        pressed.

        @param args: wildcard catchall that is used
        to catch the widget that called this method.

        @return: None
        """
        name = self.upcoming_orders.remove_selected_order()
        self.update_status('Cleared upcoming order for {}'.format(name))
    
    #===========================================================================
    # This block contains methods that are utilized to edit/adjust selected
    # MenuItem objects. This functions are all Callback methods invoked by
    # the user when their subsequent buttons are clicked. These buttons are
    # generated in the self.builder object
    #===========================================================================

    @non_fatal_error_notification
    @ErrorLogger.log_func_data
    def edit_note(self, *args):  # @IGNORE:W0613
        """Callback method when edit note button has been
        clicked. This method instantiates a new dialog window
        which the user performs the desired actions on. Upon
        closing the window is the deleted.
        
        @param *args: wildcard representing the button clicked.
        """
        menu_item = self.orders.get_selected()
        name = menu_item.get_name()
        self.update_status('Waiting for new note to be' +
                           ' edited on {}...'.format(name))
        confirmed = self.editor.edit_note(menu_item)

        message = 'updated note on ' + name

        if confirmed:
            self.orders.update_item()
            message = 'Confirmed ' + message
        else:
            message = 'Canceled ' + message

        self.update_status(message)

    @non_fatal_error_notification
    @ErrorLogger.log_func_data
    def edit_stars(self, *args):  # @IGNORE:W0613
        """Callback method when edit stars button has been
        clicked. This method instantiates a new dialog window
        which the desired actions may be performed by the user.
        Upon closing the window is deleted.
        
        @param *args: wildcard representing the button clicked
        """
        menu_item = self.orders.get_selected()
        name = menu_item.get_name()
        self.update_status("Waiting for stars value to be" +
                           " edited on {}...".format(name))
        confirmed = self.editor.edit_stars(menu_item)

        message = 'updated stars rating on ' + name

        if confirmed:
            self.orders.update_item()
            message = 'Confirmed ' + message
        else:
            message = 'Canceled ' + message

        self.update_status(message)

    @non_fatal_error_notification
    @ErrorLogger.log_func_data
    def edit_options(self, *args):
        """Callback method when edit options button has been
        clicked. This methods instantiates a new dialog window
        in which the user may perform the desired actions. Upon
        closing the dialog window is deleted.
        
        @param args: wildcard representing the button clicked

        @return: None
        """
        menu_item = self.orders.get_selected()
        name = menu_item.get_name()
        self.update_status('Waiting for options to be ' +
                           'selected on {}...'.format(name))
        response = self.editor.edit_options(menu_item)

        message = 'updated options on ' + name
        if response == Editor.ACCEPT_RESPONSE:
            message = 'Confirmed ' + message
            self.orders.update_item()

        elif response == Editor.GENERAL_OPTIONS_RESPONSE:
            self.edit_general_options()

        else:
            message = 'Canceled ' + message

        self.update_status(message)

    @non_fatal_error_notification
    @ErrorLogger.log_func_data
    def edit_general_options(self, *args):
        """Calls a general edit dialog window
        to be opened on the currently selected
        MenuItem object. This dialog window
        allows for options to be added to a MenuItem
        object from the total, general options
        data that contains all possible option choices.

        @param args: wildcard catchall that is used to
        catch the Gtk.Widget that called this method.

        @return:
        """
        menu_item = self.orders.get_selected()
        name = menu_item.get_name()
        self.update_status('Opening general options to edit ' +
                           '{}'.format(name))
        option_data = Builder.get_options_item_data()
        response = self.editor.edit_general_options(option_data, menu_item)

        if response == Editor.ACCEPT_RESPONSE:
            self.orders.update_item()

            message = 'Adding options to {}... done'.format(name)

        else:
            messsage = 'Cancelling options add to {}.'.format(name)

        self.update_status(message)


    #===========================================================================
    # This block contains methods pertaining to dialog windows that
    # are initiated by the user.
    #===========================================================================

    @non_fatal_error_notification
    @ErrorLogger.log_func_data
    def initiate_response_dialog(self, response_type):
        """Initiates a new dialog window based on the
        response type provided.

        @param response_type: int representing a
        ResponseType defined as a constant in the
        Editor module

        @return: None
        """
        if response_type == Editor.COMP_RESPONSE:
            self.comp_order()
        elif response_type == Editor.SPLIT_CHECK_RESPONSE:
            self.split_check_order()
        elif response_type == Editor.DISCOUNT_RESPONSE:
            self.discount_order()

    @non_fatal_error_notification
    @ErrorLogger.log_func_data
    def confirm_order(self, *args):  # @IGNORE:W0613
        """Callback method when confirm order button has been
        clicked. This method instantiates a new dialog window
        that the user interacts with to confirm the order and
        send it to the kitchen. Upon closing the window
        is deleted.

        @param *args: wildcard representing the button clicked.
        """
        self.update_status("Waiting to send order to kitchen...")
        current_order = self.orders.get_current_order()
        confirmed = self.editor.confirm_order(current_order, self.order_confirmed)

        if confirmed:
            self.update_status("Sending order to kitchen... sent")
        else:
            self.update_status("Cancelled sending order to kitchen")

    @non_fatal_error_notification
    @ErrorLogger.log_func_data
    def confirm_checkout(self, *args):  # @IGNORE:W0613
        """Callback method when check order button has been
        clicked. This method instantiates a new dialog window
        that prompts the user to confirm or cancel the checkout.
        
        @param *args: wildcard that represents the button pressed
        """
        self.update_status('Waiting for checkout confirmation...')
        current_order = self.orders.get_current_order()
        response = self.editor.checkout_order(current_order, self.checkout_confirm)

        if response == Editor.ACCEPT_RESPONSE:
            self.update_status('Checking out table. Clearing order... done')
        elif response == Editor.REJECT_RESPONSE:
            self.update_status('Cancelling checkout. Restoring order... done')
        else:
            self.initiate_response_dialog(response)

    @non_fatal_error_notification
    @ErrorLogger.log_func_data
    def split_check_order(self, *args):
        """Calls the split check order method to
        allow the user to perform a split check order.
        Upon confirmation performs a checkout of the order.

        @param args: wildcard catchall used to catch the
        Gtk.Widget that called this method.

        @return: None
        """
        self.update_status('Waiting for split check confirmation...')
        current_order = self.orders.get_current_order()
        confirmed = self.editor.split_check_order(current_order,
                                                  self.checkout_confirm)

        if confirmed:
            self.update_status('Splitting Checking... Clearing order')
        else:
            self.update_status('Cancelled checkout... Retrieving order')

    @non_fatal_error_notification
    @ErrorLogger.log_func_data
    def select_misc_order(self, *args):
        """Callback method when the misc order button has been pressed.
        This instantiates a Dialog for the user to interact with.
        
        @param *args: wild card that represents a catch all.
        """
        self.update_status('Waiting for order selection...')
        current_names = self.orders.get_togo_orders_list()
        confirmed = self.editor.select_misc_order(current_names,
                                                  self.order_selection_confirm_function)
        if not confirmed:
            self.update_status('Cancelled order selection')

    @non_fatal_error_notification
    @ErrorLogger.log_func_data
    def comp_order(self, *args):
        """Callback method when comp selection has been
        clicked. This method instantiates a new dialog window
        that allows the user to change the comp status of menu
        items in the selected order.

        @param args: wildcard catchall that represents the
        Gtk.Widget that called this method.

        @return: None
        """
        self.update_status('Waiting for comp confirmation...')
        current_order = self.orders.get_current_order()
        confirmed = self.editor.comp_item_order(current_order, self.update_order)

        if confirmed:
            message = 'Selected menu items comped. Retrieving order.. done'
        else:
            message = 'Cancelling comp selection. Restoring order... done'
        self.update_status(message)

    @non_fatal_error_notification
    @ErrorLogger.log_func_data
    def discount_order(self, *args):
        """Callback method when discount selection has been
        clicked. This method instantiates a new dialog window
        that allows the user to add and remove discount MenuItem
        objects to the selected order.

        @param args: wildcard catchall that is used to catch the
        Gtk.Widget that called this method.

        @return: None
        """
        self.update_status('Waiting for discount confirmation...')
        current_order = self.orders.get_current_order()
        discount_templates = Builder.get_discount_templates_data()
        confirmed = self.editor.discount_item_order(current_order, self.edit_order,
                                                    discount_templates)

        if confirmed:
            message = 'Applying Discounts... done'
        else:
            message = 'Cancelling discount selection. Restoring order... done'
        self.update_status(message)

    @non_fatal_error_notification
    @ErrorLogger.log_func_data
    def undo_checkout_order(self, checkout_data):
        """Called when the associated Gtk.Widget
        has been clicked. Allows user to interact
        with a window that will undo previously
        checked out orders and return them to the UI.

        @param checkout_data: dict where each key is represented
        by a tuple of (str, str) -> (name, date), and each value
        mapped is a list of MenuItem objects.

        @return: None
        """
        self.update_status('Waiting for Undo Checkout confirmation...')
        confirmed = self.editor.undo_checkout_order(checkout_data,
                                                    self.add_checkout_order)

        if confirmed:
            message = 'Adding undone checkout order to togo list... done'
        else:
            message = 'Cancelling undo checkout dialog.'
        self.update_status(message)


    #===========================================================================
    # This block contains methods that are called via callback only when a
    # dialog window has been confirmed.
    #===========================================================================

    @non_fatal_error_notification
    @ErrorLogger.log_func_data
    def order_confirmed(self, priority_order, *args):
        """Method called when the order has been
        confirmed as is to be sent to the kitchen.

        @param priority_order: list of MenuItem objects that
        represents the order list that has priority.
        
        @return: 2-tuple where first index is a str
        representing the order's associated name, and
        the second index is a list of MenuItem objects
        that represent the order.
        """
        self.orders.confirm_order(priority_order)
        curr_name, curr_order = self.get_order_info()
        self.upcoming_orders.add_order(curr_name, curr_order,
                                       priority_order=priority_order)

        return curr_name, curr_order

    @non_fatal_error_notification
    @ErrorLogger.log_func_data
    def checkout_confirm(self, *args):
        """Callback method when the checkout window has been confirmed.
        
        @param *args: wildcard as a catch all
        
        @return:  2-tuple where first index is a str
        representing the order's associated name, and
        the second index is a list of MenuItem objects
        that represent the order.
        """
        curr_name, curr_order = self.get_order_info()
        self.upcoming_orders.remove_by_name(curr_name)
        self.orders.clear_order()
        return curr_name, curr_order

    @non_fatal_error_notification
    @ErrorLogger.log_func_data
    def order_selection_confirm_function(self, curr_order):
        """Callback method that is called when a given TOGO confirmation
        dialog has been confirmed. Sets the GUI for menu items to be
        added to the order created or selected.
        
        @param curr_order: either a 3-tuple representing a togo order,
        or a string representing a misc table.
        """
        if type(curr_order) is tuple:
            self.orders.select_togo_order(curr_order)
            self.builder.set_table(curr_order[0])
        else:
            self.table_button_clicked(None, curr_order)

    @non_fatal_error_notification
    @ErrorLogger.log_func_data
    def add_reservation_confirmed(self, new_reservation):
        """Callback method that is called when the new reservation
        has been added and confirmed.

        @param new_reservation: 3-tuple of (str, str, float) representing
        the name, number, and arrival time of the reservation.

        @return: None
        """
        name = new_reservation[0]
        number = new_reservation[1]
        arrival = new_reservation[2]

        self.reservations.add_reservation(name, number, arrival)

    @non_fatal_error_notification
    @ErrorLogger.log_func_data
    def update_order(self, updated_order=None):
        """Callback Method that is called to update the
        order with the given updated order.

        @keyword updated_order: list of MenuItem objects
        that is the updated data. Default value is None
        if the order is to be updated from currently
        stored order.

        @return: None
        """
        #updated_order may be used to display information
        # at later time. order class doesn't require an
        # argument to update it's order.
        self.orders.update_order()

    @non_fatal_error_notification
    @ErrorLogger.log_func_data
    def edit_order(self, edited_order):
        """Callback Method that is called to edit
        the order with the given edited order.

        @param edited_order: list of MenuItem objects
        that is the edited order. This list will replace
        the currently stored information in the order
        object.

        @return: None
        """
        self.orders.edit_order(edited_order)

    @non_fatal_error_notification
    @ErrorLogger.log_func_data
    def add_checkout_order(self, imported_order):
        """Adds the given, previously checked out
        order to the current orders displayed.

        @param imported_order: list of MenuItem
        objects that represents an order that
        was previously checked out and is being
        imported.

        @return: None
        """
        for key in imported_order:
            self.orders.load_new_order(key, imported_order[key])

    #===========================================================================
    # This block contains methods that are used for obtaining information
    # about the current order, menu item, or other things the components
    # of this class are operating on, and would be necessary to know external
    # to the this class
    #===========================================================================

    @non_fatal_error_notification
    @ErrorLogger.log_func_data
    def get_order_info(self):
        """Gets the current information associated
        with the current order.
        
        @return: 2-tuple representing the information
        of the table. The first entry represents the
        table number or order information, and the
        second entry represents the MenuItem list associated
        with that entry.
        """
        return self.orders.get_order_info()

    #===========================================================================
    # This block contains methods that are used to display information about
    # the UI's operations to the user via the builder object.
    #===========================================================================

    @non_fatal_error_notification
    @ErrorLogger.log_func_data
    def update_status(self, message, styles=[]):
        """Updates the status displayed in the main window
        to the message given with the style parameters.

        @param message: str representing the message to
        display.

        @param styles: list of str, representing the styles
        to be applied to the message. Current options are
        'error' , 'bold', and 'italic'.

        @return: bool value if the status was updated. True
        if yes, false if no.
        """
        return self.builder.update_status(message, styles)

    #==============================================================================
    # This block contains methods that relate to the functioning of the
    # error logging system for the GUI. This includes dumping, debugging and
    # other logging methods.
    #==============================================================================

    @non_fatal_error_notification
    @ErrorLogger.log_func_data
    def update_menu_items(self, *args):
        """This method is called when an associated Gtk.Widget
        is clicked. This method calls the Editor object to initiate
        the update menu items procedure.

        @param args: wildcard catchall that is used to catch
        the Gtk.Widget that called this method.

        @return: None
        """
        menu_data = Builder.load_menu_items()
        options_data = Builder.get_options_item_data()

        self.update_status('Awaiting editing of raw MenuItem data...')
        response = self.editor.update_menu_items_data(menu_data, options_data,
                                                      self.dump_updated_menu_data)

        if response:
            self.update_status('Edited MenuItem data. Restart to see updates')
        else:
            self.update_status('Cancelled updating MenuItem data.')

    @non_fatal_error_notification
    @ErrorLogger.log_func_data
    def update_discount_templates(self, *args):
        """This method is called when the associated
        widget is pressed. This method displays a dialog
        window that the user can interact with to update
        the stored discount templates.

        @param args: wildcard catchall that is used to
        catch the Gtk.Widget that called this method.

        @return: None
        """
        discount_templates = Builder.get_discount_templates_data()

        self.update_status('Awaiting editing of raw Discount Templates...')
        response = self.editor.update_discount_templates(self.dump_discount_templates,
                                                         discount_templates)
        if response:
            self.update_status('Edited Discount templates.')
        else:
            self.update_status('Cancelled Discount templates update.')

    def update_option_items(self, *args):
        """This method is called when the associated
        widget is pressed. This method displays a dialog
        window that the user can interact with to update
        the stored general OptionItem data.

        @param args: wildcard catchall that is used to
        catch the Gtk.Widget that called this method.

        @return: None
        """
        option_data = Builder.get_options_item_data()

        self.update_status('Awaiting editing of raw OptionItem data...')
        response = self.editor.update_option_items_data(option_data,
                                                self.dump_updated_option_data)
        if response:
            message = 'Edited stored General OptionItem data.'
        else:
            message = 'Cancelled updating stored General OptionItem data.'

        self.update_status(message)

    @non_fatal_error_notification
    @ErrorLogger.log_func_data
    def dump_updated_menu_data(self, updated_menu_data):
        """Callback Method.

        Called when the menu data has been updated. This
        method is used to call the associated methods to
        dump the updated MenuItem data.

        @param updated_menu_data: dict of str key to list
        of MenuItem object value pairs. Each str key represents
        the category and has an associated list of MenuItems.

        @return: None
        """
        Builder.update_menu_items_data(updated_menu_data)

    @non_fatal_error_notification
    @ErrorLogger.log_func_data
    def dump_discount_templates(self, updated_discount_templates):
        """Callback Method.

        Called when the discount template data has been updated.
        This method is used to call the associated methods to
        dump the updated discount templates.

        @param updated_discount_templates: list fo tuples that
        represents discount templates.

        @return: None
        """
        Builder.update_discount_templates_data(updated_discount_templates)

    def dump_updated_option_data(self, updated_option_data):
        """Called when the update option items has been
        updated. This method is used to call the associated
        methods necessary to dump the General OptionItem
        data into its associated file.

        @param update_option_data: str of keys representing
        the OptionItem categories, mapped to list of OptionItems
        that represent the options associated with that category.

        @return: None
        """
        Builder.update_options_item_data(updated_option_data)

    def _dump(self):
        """Dumps the information regarding the
        associated objects into a dictionary and
        returns it. This is used primarily for
        debugging purposes.

        @warning: This method could unintentionally
        cause errors or loss of information if it
        has been called and the objects are then
        interacted with.

        @return: dict where each entry represents
        stored information at the exact time of
        this call.
        """
        dump_site = {}

        dump_site['orders'] = self.orders._dump()
        dump_site['upcoming_orders'] = self.upcoming_orders._dump()
        dump_site['reservations'] = self.reservations._dump()

        return dump_site

